---
output:
  github_document:
    html_preview: false
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# groups

<!-- badges: start -->
<!-- badges: end -->

The groups package provides a more powerful version of grouped tibbles from dplyr. It allows groups in a tibble to be marked inapplicable, which is a simple but widely useful way to express structure in a dataset. It also provides replacements for common tidyverse functions that are centered around groupings with potentially inapplicable values.

## Motivation

Groupings with inapplicable values can make many data cleaning tasks more straightforward to express. Here are some examples:

**Calculation on a subset**. In a dataset containing two groups, A and B, it is not easy to express that you want to calculate the square roots of all A values, storing them in a new column, and filling the remaining rows with NA. This can easily be expressed if B can be marked as an inapplicable group.

**Hierarchical groups**. Imagine you have groups A and B, and within A you also have subgroups S1 and S2. If you have some data that is relevant to the entirety of group A, you must include the rows in both subgroups. An "inapplicable" subgroup can indicate that the data applies to the whole primary group.

**Pivoting**. Pivoting operations essentially [convert groups of data](https://epinotes.netlify.app/post/pivoting/) into columns of data, and vice versa. Some kinds of pivots cannot be expressed by a single tidyr pivot statement and require two or even three consecutive pivot calls. Inapplicable groups can be used to describe some of these more complex operations in a very straightforward way.

## Usage

Install:

```{r eval=FALSE}
devtools::install_github("ngriffiths21/groups")
```

Group and mark inapplicables:

```{r}
library(groups)
igrped_df <- group_by2(iris, Species = "setosa")

dplyr::group_data(igrped_df)
```

Make row groups out of columns (pivot longer):

```{r}
p_df <- group_by2(iris, Species = NULL)

pivot_grps(p_df, rows = list(value = c("Sepal.Length", "Sepal.Width")))
```

Make columns out of row groups:

```{r include=FALSE}
p_df2 <- tibble::tribble(
  ~ grp1, ~ grp2, ~ val,
  "A", 1, 1.9,
  "A", 2, 10.1,
  "B", 2, 3.1,
  "B", 1, 4.7,
  "C", NA, 4.9
)
```

```{r}
p_df2

# group and make the NA an inapplicable grouping
p_df2 <- group_by2(p_df2, grp1 = NULL, grp2 = NA)

pivot_grps(p_df2, cols = "grp1")
```

Note that with this inapplicable grouping, the value from the "C" group is applied to both subgroups.

Pivot both rows and columns:

```{r}
p_df3 <- pivot_grps(p_df2, cols = "grp1")

pivot_grps(p_df3, rows = list(val = c("val_A", "val_B", "val_C")),
           cols = "grp2")
```

## Lifecycle

This package is experimental and the API is expected to change.

## License

[MIT](https://choosealicense.com/licenses/mit/)
